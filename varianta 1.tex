\section*{Varianta 1}


1.1. Variabila a este de tip real. Pentru a verifica dacă valoarea variabilei a aparține mulțimii $[-3,2] \mathrm{U}\{3,5,9\}$ se va utiliza următoarea expresie:
\\
a) \begin{verbatim}
Limbajul C++/ Limbajul C
!((a<-3) || (a>2)) || (a==3) || (a==5) || (a==9)
Limbajul Pascal
not ((a<-3) or (a>2)) or (a=3) or (a=5) or (a=9)
\end{verbatim}
\\
b) \begin{verbatim}
Limbajul C++/ Limbajul C
(a>=-3)&&(a<=2)&&(a==3) || (a==5) || (a==9)
Limbajul Pascal
(a>=-3) and (a<=2) and (a=3) or (a=5) or (a=9)
\end{verbatim}
\\
c) \begin{verbatim}
Limbajul C++/ Limbajul C
(a>-3) && (a<2) || (a==3) || (a==5) || (a==9)
Limbajul Pascal
(a>-3) and (a<2) or (a=3) or (a=5) or (a=9)
\end{verbatim}
\\
d) \begin{verbatim}
Limbajul C++/ Limbajul C
(a<-3)||(a>2) && (a==3) && (a==5) && (a==9)
Limbajul Pascal
(a<-3) or (a>2) and (a=3) and (a=5) and (a=9)
\end{verbatim}
\\
e) \begin{verbatim}
Limbajul C++/ Limbajul C
(a>=-3)||((a<=2)&&(a==3)) || (a==5) || (a==9)
Limbajul Pascal
(a>=-3) or ((a<=2) and (a=3)) or (a=5) or (a=9)
\end{verbatim}
\\
f) \begin{verbatim}
Limbajul C++/ Limbajul C
(a>=-3) || !((a>2)) || (a==3)) || (a==5) || (a==9)
Limbajul Pascal
(a>=-3) or not((a>2)) or (a=3)) or (a=5) or (a=9)
\end{verbatim}
\\
1.2. Precizați cu ce expresie trebuie înlocuite punctele de suspensie, astfel încât în urma executării secvenței alăturate, să se deplaseze elementele $\mathbf{x}_{\mathbf{p}}, \mathbf{x}_{\mathbf{p}+\mathbf{1}}, \ldots, \mathbf{x}_{\mathbf{k}}$ ale unui tablou unidimensional $\mathbf{x}, \mathbf{c u} \mathbf{q - 1}$ poziții spre dreapta.
\begin{verbatim}
Limbajul C++/ Limbajul C
for (j=k; j>=p; j--)
    x[...]=x[j];
Limbajul Pascal
for j:= k downto p do
    x[...]:=x[j];
\end{verbatim}
\\
a) $q-1-j$
\\
b) $j-q+1$
\\
c) $q-1+j$
\\
d) $q-2+j$
\\
e) $q-j+1$
\\
f) $j+q-3$
\\
1.3. Precizați ce se va afișa după executarea secvenței de program de mai jos.
\begin{verbatim}
Limbajul C++/ Limbajul C
char a[20]="informatica", b[20]="";
strncat(b,a,strlen(strchr(a,'t')));
cout<<b; | printf("% s", b);
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
var b : string[20];
begin b:='informatica';
delete(b, pos('r', b) , pos ('a', b); 
write (b) ;
end.
\end{verbatim}
\\
a) tica
\\
b) form
\\
c) ica
\\
d) inf
\\
e) rmatica
\\
f) info
\\
1.4. Precizați care dintre următoarele secvențe calculează suma elementelor de pe linia $\mathbf{p}$, ale unui tablou bidimensional $\mathbf{x}$, cu $\mathbf{m}$ linii și $\mathbf{n}$ coloane (numerotate de la $\mathbf{1}$ la $\mathbf{m}$, respectiv de la 1 la $\mathbf{n}$ )
\\
a) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0;
for (i=m; i>=1; i--)
    s=s+x[p][i];
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0;
for i:=m downto 1 do
  s:=s+x[p, i];
\end{verbatim}
\\
b) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0; i=1;
while(i<=m)
{ s=s+x[i][p];
        i++;}
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0; i:=1;
while i<=m do
  begin
    s:=s+x[i, p];
    i:=i+1;
  end;
\end{verbatim}
\\
c) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0;
for(i=n; i>=1; i--)
    s=s+x[i][p];
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0;
for i:=n downto 1 do
  s:=s+x[i, p];
\end{verbatim}
\\
d) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0; i=1;
while(i<=n)
    {s=s+x[p][i];
            i++;}
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0; i:=1;
while i<=n do
  begin
    s:=s+x[p,i];
    i:=i+1;
  end;
\end{verbatim}
\\
e) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0;
for (i=m; i>1; i--)
    s=s+x[p][i];
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0;\\
for i:=m downto 2 do
s:=s+x[p,i];
\end{verbatim}
\\
f) Limbajul C++/ Limbajul C
\begin{verbatim}
s=0;
for(i=m; i>=1; i--)
    s=s+x[i][p];
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
s:=0;\\
for i:=m downto 1 do
s:=s+x[i, p];
\end{verbatim}
\\
1.5. Fie graful orientat cu 5 noduri numerotate de la 1 la 5 , și arcele $(1,2),(2,3),(3,1),(3,4)$, $(4,5),(5,4)$. Precizați care este matricea drumurilor asociată acestui graf. Matricea drumurilor este o matrice pătratică de dimensiune nxn, definită astfel:
Limbajul C++/ Limbajul C
\begin{verbatim}
- a[i][j]=1 dacă există cel puțin un drum de la nodul i la nodul j
- a[i][j]=0 dacă nu există niciun drum de la nodul i la nodul j
\end{verbatim}
Limbajul Pascal
\begin{verbatim}
- a[i, j]=1 dacă există cel puțin un drum de la nodul i la nodul j
- a[i, j]=0 dacă nu există niciun drum de la nodul i la nodul $j$
\end{verbatim}
\\
a) \begin{verbatim}
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
0 0 0 1 1
0 0 0 1 1
\end{verbatim}
\\
b) \begin{verbatim}
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
0 0 0 0 1
0 0 0 1 0
\end{verbatim}
\\
c) \begin{verbatim}
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
0 0 1 1 1
0 0 0 1 1
\end{verbatim}
\\
d) \begin{verbatim}
0 1 0 0 0
0 0 1 0 0
1 0 0 1 0
0 0 0 0 1
0 0 0 1 0
\end{verbatim}
\\
e) \begin{verbatim}
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 0 0 1 1
0 1 0 1 1
\end{verbatim}
\\
f) \begin{verbatim}
1 1 0 0 0
0 0 1 0 0
1 0 0 1 1
0 1 0 0 1
1 0 0 1 0
\end{verbatim}
\\
1.6. Utilizând metoda backtracking se generează elementele produsului cartezian a n mulțimi: $\mathbf{A}_{1}, \mathbf{A}_{2}, \ldots, \mathbf{A n}_{\mathbf{n}}$. Utilizând acest algoritm pentru a genera elementele produsului cartezian a 3 mulțimi: $\mathbf{A}_{\mathbf{1}}=\{1,2,3\}, \mathbf{A}_{2}=\{1,2\}$ și $\mathbf{A}_{3}=\{1,2,3,4\}$ atunci, precizați care din următoarele secvențe nu reprezintă o soluție a acestui algoritm, pentru produsul $\mathbf{A}_{3} \times \mathbf{A}_{2} \times \mathbf{A}_{1}$.
\\
a) $(4,2,3)$
\\
b) $(3,3,3)$
\\
c) $(3,2,1)$
\\
d) $(1,1,1)$
\\
e) $(4,1,2)$
\\
f) $(3,1,3)$
\\
1.7. Fie funcția $p$ definită mai jos
\begin{verbatim}
Limbajul C++/ Limbajul C
int p (int a, int b)
{if (b==0) return 0;
    else
      if (a%b==0) return p(a, b-1)+1;
            else return p(a, b-1);}
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
function p (a, b: integer) : integer;
begin
if b=0 then p:=0
else
    if a mod b=0 then p:=p(a, b-1)+1
        else p:=p(a, b-1);
end;
\end{verbatim}
precizați care este apelul corect al funcției $\mathbf{p}$ pentru a verifica dacă un număr $\mathbf{x}$ este prim.
\\
a) Limbajul C++/ Limbajul C
if (p(x, x)==2)  cout<<"prim"; | printf("prim");
Limbajul Pascal
if p(x, x)=2 then write('prim');
\\
b) Limbajul C++/ Limbajul C
if (p(2, x)==2)  cout<<"prim"; | printf("prim");
Limbajul Pascal
if p(2, x)=2 then write('prim');
\\
c) Limbajul C++/ Limbajul C
if (p(x, 2)==0)  cout<<"prim"; | printf("prim");
Limbajul Pascal
if p(x, 2)=0 then write ('prim');
\\
d) Limbajul C++/ Limbajul C
if (p(x, x / 2)==2) cout<<"prim"; | printf("prim");
Limbajul Pascal
if p(x, x div 2)=2 then write('prim');
\\
e) Limbajul C++/ Limbajul C
if (p(x, 2)==x) cout<<"prim"; | printf("prim");
Limbajul Pascal
if p(x, 2)=x then write('prim');
\\
f) Limbajul C++/ Limbajul C
if (p(2, x)==1) cout<<"prim";  | printf("prim");
Limbajul Pascal
if p(2, x)=1 then write('prim');
\\
1.8. Un arbore are nodurile numerotate cu numere de la 1 la 5 . Vectorul de tați asociat arborelui poate fi:
\\
a) $5,4,2,1,3$
\\
b) $2,1,0,3,4$
\\
c) $5,2,4,5,0$
\\
d) $2,4,0,3,4$
\\
e) $0,2,4,5,0$
\\
f) $1,4,0,3,4$
\\
1.9. Se consideră subprogramul $\mathbf{t}$ având definiția următoare:
\begin{verbatim}
Limbajul C++
void t(int &x, int y)
{ x=x-1; y=x+1;
    cout<<x<<<y;
}
Limbajul C
void t(int *x, int y)
{ *x=*x-1; y=*x+1;
    printf("%d%d",*x,y);
}
Limbajul Pascal
procedure t(var x: integer; y: integer);
begin
    x:=x-1; y:=x+1;
    write(x, y);
end;
\end{verbatim}
Dacă inițial $x=3$ și $y=7$, precizați ce se va afișa în urma executării secvenței de instrucțiuni:
\begin{verbatim}
Limbajul C++
t(y,y);
cout<<x<<<y;
t(y,x);
\end{verbatim}
\begin{verbatim}
Limbajul C
t(&y,y);
printf( "%d%d",x,y);
t(&y,x);
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
t(y,y);
write(x,y);
t(y,x);
\end{verbatim}
\\
a) 673556
\\
b) 676767
\\
c) 673767
\\
d) 768978
\\
e) 656376
\\
f) 673656
\\
1.10. Funcția par cu parametrii de tip întreg a și b determină numărul de valori pare din intervalul [ $\mathbf{a}, \mathbf{b}$ ], ( $\mathbf{a}<\mathbf{b}$ ). Precizați care din următoarele expresii este adevărată, pentru orice numere a și $\mathbf{b}$ care nu au aceeași paritate.
\\
a) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a, b) == b-a
Limbajul Pascal
par(a, b)=b-a
\end{verbatim}
\\
b) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a, b) == (b-a-1)/2
Limbajul Pascal
par(a, b)=(b-a-1) DIV 2
\end{verbatim}
\\
c) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a, b) == (b-a+1)/2
Limbajul Pascal
par(a, b)=(b-a+1) DIV 2
\end{verbatim}
\\
d) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a, b) == par(a, b +1)
Limbajul Pascal
par(a, b)==par(a, b+1)
\end{verbatim}
\\
e) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a,b) == (b-a)/2
Limbajul Pascal
par(a, b)=(b-a) DIV 2
\end{verbatim}
\\
f) \begin{verbatim}
Limbajul C++/ Limbajul C
par(a, b) == par(a+1, b)
Limbajul Pascal
par(a, b)=par(a+1, b)
\end{verbatim}
\\
1.11. Fie antetul funcției mini:
\begin{verbatim}
Limbajul C++/ Limbajul C
int mini (int x, int y)
Limbajul Pascal
function mini(x,y : integer): integer;
\end{verbatim}
care returnează minimul dintre valorile variabilelor $\mathbf{x}$ și $\mathbf{y}$. Precizați instrucțiunea prin care se înlocuiesc punctele de suspensie, astfel încât la finalul executării secvenței de mai jos, să se afișeze minimul dintre elementele tabloului unidimensional $\mathbf{v}$, care are 30 de elemente întregi aflate pe pozițiile $1,2, \ldots, 30$.
\begin{verbatim}
Limbajul C++/ Limbajul C
c = mini(v[1], v[2]);
for(i=3; i<=30; i++)
.........................
cout<<c; | printf("%d",c);

Limbajul Pascal
c :=mini(v[1],v[2]);
for i :=3 to 30 do
........................
writeln(c);
\end{verbatim}
\\
a) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(v[i],v[i+1]);
Limbajul Pascal
c:=mini(v[i],v[i+1]);
\end{verbatim}
\\
b) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(mini(v[i],v[1]),v[i+1]);
Limbajul Pascal
c:=mini(mini(v[i],v[1]),v[i+1]);
\end{verbatim}
\\
c) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(c, v[i]);
Limbajul Pascal
c:=mini(c, v[i]);
\end{verbatim}
\\
d) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(v[1], v[i]);
Limbajul Pascal
c:=mini(v[1], v[i]);
\end{verbatim}
\\
e) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(v[i], v[i-1]);
Limbajul Pascal
c:=mini(v[i], v[i-1]);
\end{verbatim}
\\
f) \begin{verbatim}
Limbajul C++/ Limbajul C
c =mini(c, v[30]);
Limbajul Pascal
c:=mini(c, v[30]);
\end{verbatim}
\\
1.12. Precizați ce va conține variabila s după executarea următoarei secvențe de instrucțiuni.
\begin{verbatim}
Limbajul C++/ Limbajul C
char s[30]="AdmiTerE";
int i;
for (i=0; i<strlen(s); i++)
    if (s[i]>='A' && s[i]<='Z')
            s[i]=s[i]+32;
        else
            strcpy(s+i, s+i+1);
cout<<s; | printf("%s", s);
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
var s: string[29];
    i: integer;
s:='AdmiTerE' ;
for i:=1 to length(s) do
    if s[i] in ['A'..'Z'] then
            s[i] := chr(ord(s[i])+32)
        else
            delete(s,i,1);
write(s);
\end{verbatim}
\\
a) ate
\\
b) amtre
\\
c) amre
\\
d) aTe
\\
e) amTr
\\
f)are
\\
1.13. Pentru următoarele declarări:
\begin{verbatim}
Limbajul C++/ Limbajul C
typedef struct {
    char nume[20];
    int nr;
    int nota[15];
} elev;
elev e[28], x;
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
type elev = record
    nume : string[19];
    nr : integer;
    nota : array[1..14] of integer;
end;
var e: array[1..27] of elev;
x: elev;
\end{verbatim}
precizați care dintre următoarele instrucțiuni este corectă din punct de vedere sintactic.
\\
a) \begin{verbatim}
Limbajul C++/ Limbajul C
e[10] = x;
Limbajul Pascal
e[10] := x;
\end{verbatim}
\\
b) \begin{verbatim}
Limbajul C++/ Limbajul C
e[10] = x.nr;
Limbajul Pascal
e[10] := x.nr;
\end{verbatim}
\\
c) \begin{verbatim}
Limbajul C++/ Limbajul C
e[10] = e.nota[10];
Limbajul Pascal
e[10] := e.nota[10];
\end{verbatim}
\\
d) \begin{verbatim}
Limbajul C++/ Limbajul C
elev. nota[5] = 7;
Limbajul Pascal
elev. nota[5] := 7;
\end{verbatim}
\\
e) \begin{verbatim}
Limbajul C++/ Limbajul C
x.nota = x.nota+1;
Limbajul Pascal
x. nota := x. nota +1;
\end{verbatim}
\\
f) \begin{verbatim}
Limbajul C++/ Limbajul C
x.nr = x.nota;
Limbajul Pascal
x.nr := x.nota;
\end{verbatim}
\\
1.14. Precizați câte grafuri neorientate distincte, cu 6 noduri, numerotate de la 1 la 6 , se pot construi, astfel încât nodul 2 să aibă gradul 1. Două grafuri sunt distincte dacă matricele lor de adiacență sunt diferite.
\\
a) 46
\\
b) 256
\\
c) $6!$
\\
d) 1024
\\
e) 2345
\\
f) 5120
\\
1.15. Pentru funcția $\mathbf{g}$ definită mai jos, precizați valoarea care se returnează în urma apelului g(2,1).
\begin{verbatim}
Limbajul C++/ Limbajul C
int g(int x, int y)
{ if (x > 0)
    { if (y == 0) return g(x-1,1);
        if (y > 0) return g(x-1, g(x,y-1));
        }
return y+1;
}
\end{verbatim}
\begin{verbatim}
Limbajul Pascal
function g(x,y: integer): integer;
begin
if x>0 then begin
        if y=0 then g:=g(x-1,1);
    if y>0 then g:=g(x-1,g(x,y-1));
            end
    else g:=y+1;
end;
\end{verbatim}
\\
a) 3
\\
b) 4
\\
c) 5
\\
d) 6
\\
e) 7
\\
f) 10
\\